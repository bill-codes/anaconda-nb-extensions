#!/usr/bin/env python
import os
import shutil
import site
import subprocess
import sys

from os.path import join, exists, dirname

from jupyter_core import paths
from notebook.notebookapp import NotebookApp

import logging
logger = logging.getLogger(__name__)

# WAKARI-specificity
# TODO: Migrate it to ipython-we
wk_project_home = os.environ.get('WAKARI_PROJECT_HOME')

if wk_project_home:
    import getpass
    import IPython
    import tempfile

    # CHECK: Recently this function was refactored in the notebook, we should check
    # if this is still valid as is...
    def _copy_metadata(src, dst):
        """IPython uses this to copy metadata (perms) from
        src to dst.  However when new notebooks are created,
        dst does not exist.  When new notebooks are created
        usually this function fails, and src is renamed to
        dst. So what we do is make a tempfile, which will
        have the inherited ACLs, and then copy those to
        both the source and the dst.
        """
        base = dirname(dst)
        path = tempfile.NamedTemporaryFile(dir=base).name
        try:
            with open(path, "w+") as f:
                try:
                    shutil.copymode(path, src)
                except:
                    pass
                try:
                    shutil.copymode(path, dst)
                except:
                    pass
            st = os.stat(src)
            if hasattr(os, 'chflags') and hasattr(st, 'st_flags'):
                os.chflags(dst, st.st_flags)
        finally:
            os.remove(path)


    IPython.utils.io._copy_metadata = _copy_metadata

    # CHECK: We should check if this is still valid as the notebook
    old_ensure_dir_exists = IPython.utils.path.ensure_dir_exists

    def ensure_dir_exists(path, mode=None):
        if mode:
            logger.error("we don't allow you to pass a mode for ensure_dir_exists, as it conflicts with ACLs")
        return old_ensure_dir_exists(path, mode=0o777)

    IPython.utils.path.ensure_dir_exists = ensure_dir_exists

    # Setup jupyter_config_dir and jupyter_data_dir into ipython_<user>
    # Wakari run on linux boxes so it is safe to look for this locations
    jupyter_config_dir = join(wk_project_home , '.jupyter_%s' % getpass.getuser())
    jupyter_data_dir = join(wk_project_home , '.local', 'share',  'jupyter_%s' % getpass.getuser())
else:
    # Setup jupyter_config_dir and jupyter_data_dir into the environment
    jupyter_config_dir = paths.ENV_CONFIG_PATH[0]
    jupyter_data_dir = paths.ENV_JUPYTER_PATH[0]

# HACK to make read jupyter_config_dir from env because right now the frontend
# config could be only loaded from the user space
os.environ["JUPYTER_CONFIG_DIR"] = jupyter_config_dir
os.environ["JUPYTER_DATA_DIR"] = jupyter_data_dir

# Our own copytree, we are forcing the installation on every start
# TODO: we probably need a soft default checking if there is a file or folder
# and enable a --force option.
# TODO: evaluate the migration to use the jupyter nbextension install mechanism
def copytree(src, dst, is_file=False):
    if not is_file:
        if exists(dst):
            shutil.rmtree(dst)
        return shutil.copytree(src, dst)
    else:
        if exists(dst):
            os.remove(dst)
        return shutil.copyfile(src, dst)

# NOTE: all the config and data files (extensions) are copied by the conda recipe
# TODO: use config manager to load the extension
# TODO: load theme by template
# TODO: put template and logo into anaconda_custom

# Copy nbserextensions extensions
# TODO: deal with installation in the extension conda recipe, not here...
nbserextensions = ['conda-envs']

site_packages = site.getsitepackages()[0]

for nbserextension in nbserextensions:
    copytree(join(jupyter_data_dir, 'nbserextensions', nbserextension),
             join(site_packages, nbserextension))

# Run the syncer
# TODO: we need to evaluate the migration of this to a server-based extension
# triggered before the notebook load the kernels...
# TODO: Use a KernelSpec custom manager to do this...
cmd = [sys.executable,
       join(jupyter_data_dir, 'nbextensions', 'syncer', 'sync.py'),
       '-p',
       join(jupyter_data_dir, 'kernels')]

subprocess.check_call(cmd)

# Launch the notebook instance with the proper args
args = sys.argv

if len(args) == 1:
    args = []
else:
    args = args[1:]

# Load our custom config file
args = args + ["--JupyterApp.config_file=" + 
               join(jupyter_config_dir, "anaconda_notebook_config.py")]

# TODO:
# * Launch from the executable but also from jupyter notebook --anaconda
# * Provide options to install into the --user ans --system space
# * Deal with extension installed from outside the repo
NotebookApp.launch_instance(argv=args)
